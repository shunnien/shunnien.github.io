---
title: CSS Grid 筆記 21-Flexbox vs CSS Grid
categories: 程式技術筆記
tags:
  - CSS
  - CSSGrid25
toc: false
date: 2018-04-30 10:40:33
---


![demo](https://lh3.googleusercontent.com/vMv0bgtJdPzDyEogYVweLXaY6l1AwP4av81PbQk2p5eGRMtRmEar_5haJcWCPx63YYTamCtVfo2Lx2L4_NFTBVW_kz6kjrH-erK0rVprdqw2JLzQdQ78EWT4Ttrjgjd-ChQ9nPFlgQi3yDxQEu1y9NJo2WBKhxGlOr_Mm0ghHsM7Xd9aP0gLAq8kCb4c2XIIEzQj3YC962hoDIkZWO9qPrF6XNRmde40zDVXl9gGVyKHJ87fwfsCEttNX1OuB86bqaBi22NmBbzdQd4Z1wVtRogVPLjLVMRkkP5NjK1kn7LMGLk6Cz5E5Co7oVp3iTCaApDKHYEwmrWtMyI_I5JqZdR7hrnBsFjKwveLzBDrmaS_HPdRwg0bKxxZNfTo68XA3akJ3Zae6_0WfPA4hQV6aN3yDJNZh4NohUKsyCh81AyXaj6AqmcDvcD90hDHB2fSWIF1_-jqTeuYIs2RZEqqXm0GwPthUUK3jg8ni9GEdGCZB8ZCoPom3He1cLqqYFMNE_7FENoe3X-9I0JmzP7hciBmVnTpfNbtDG3XnjDgiGt5Z1PRllECTe7_qiuBf1wxo5IElK_KMx-vrs6vpxwORorHsQSEA6VZf1L59rQSrh0_3acE2hnCkhA2LT1LVFyd4DJmaveAaprVsyIsObG3OwJRVgcWOkgv=w321-h339-no)

此篇是透過幾個不同的練習範例，運用 **flexbox** 或是 **css grid** 來達成目標結果<!-- more -->

> [Demo](https://shunnien.github.io/css-grid25day/day_21/index.html) | [Github](https://github.com/shunnien/css-grid25day)

# Flexbox vs CSS Grid

此篇練習了以下幾個主題

- Axis Flipping!
- Controls on Right!
- Flex on Item!
- Perfectly Centered!
- Self Control!
- Stacked Layout!
- Unknown Content Size!
- Unknown Number of Items!
- Variable Widths on Each Row!

## Axis Flipping

練習使用 [**auto-fit**](https://shunnien.github.io/2018/03/24/css-grid-12/) 來達到基準軸線的變動

``` css
.flipper {
    display: grid;
    grid-gap: 10px;
    grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
}

.flipper.flip {
    grid-template-columns: 1fr;
}
```

## Controls on Right

把控制的項目置右，主要是 [**grid-auto-flow**](https://shunnien.github.io/2018/03/18/css-grid-06/)

``` css
.track {
    background: white;
    padding: 10px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    display: grid;
    grid-template-columns: 1fr;
    grid-auto-flow: column;
}
```

## Flex on Item

可以使用 **flex** 或是 **grid** 來達成

> 使用 **flex**

``` css
.controls {
    margin: 200px 0;
    display:flex;
    align-items: center;
}

.scrubber {
    background: #BADA55;
    height: 10px;
    min-width: 100px;
    border-radius: 10px;
    flex: 1;
}
```

> 使用 **grid**

``` css
.controls {
    margin: 200px 0;
    display: grid;
    grid-template-columns: auto auto auto 1fr auto auto;
    align-items: center;
}

.scrubber {
    background: #BADA55;
    height: 10px;
    min-width: 100px;
    border-radius: 10px;
}
```

## Perfectly Centered

此練習也是兩種方法都可以達成

> **flex**

``` css
.hero {
    height: 200px;
    background: rgba(255, 255, 255, 0.2);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
}
```

> **grid**

``` css
.hero {
    height: 200px;
    background: rgba(255, 255, 255, 0.2);
    display: grid;
    align-content: center;
    justify-items: center;
}
```

## Self Control

讓區塊資料按照邊框對齊

``` css
.corners {
    display: grid;
    height: 200px;
    width: 200px;
    border: 10px solid var(--yellow);
    grid-template: 1fr 1fr/1fr 1fr;
    align-items: end;
    justify-items: end;
}

.corner:nth-child(1),
.corner:nth-child(2) {
    align-self: start;
}

.corner:nth-child(1),
.corner:nth-child(3) {
    justify-self: start;
}
```

## Stacked Layout

排列多行，且內容的大小一致，其間格按照各行的剩餘空間平均分配

``` css
.stacked {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-around;
}

.stacked>* {
    width: 30%;
    margin-bottom: 20px;
}
```

## Unknown Content Size

把一個縱列變成橫列

``` css
.known {
    margin: 100px 0;
    display: grid;
    grid-template-columns: repeat(5,auto);
    grid-gap: 20px;
    justify-content: center;
}
```

## Unknown Number of Items

不知道內容元素的數量，利用 **auto-fit** 來調整

``` css
.unknown {
    display: grid;
    grid-template-columns: repeat(auto-fit ,minmax(50px, 1fr));
    grid-gap: 20px;
}
```

## Variable Widths on Each Row

每一元素寬度都不同

``` css
.flex-container {
    display: flex;
    flex-wrap: wrap;
    border: 1px solid black;
}

.flex-container>* {
    margin: 10px;
    flex: 1;
}
```

## 線上展示

{% jsfiddle 33w055n3 result,html,css,js dark %}

# 筆記與備註事項

## [flex-direction][2]

{% note info %}
CSS flex-direction 属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。

注意，值 row 和 row-reverse 受 flex 容器的方向性的影响。 如果它的 dir 属性是 ltr，row 表示从左到右定向的水平轴，而 row-reverse 表示从右到左; 如果 dir 属性是 rtl，row 表示从右到左定向的轴，而 row-reverse 表示从左到右。

**資料來源** - [*MDN*](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction)
{% endnote %}

## [flex-wrap][4]

{% note info %}
CSS flex-wrap 指定 flex 元素单行显示还是多行显示 。如果允许换行，这个属性允许你控制行的堆叠方向。
**資料來源** - [*MDN*](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap)
{% endnote %}

# 參考資料

- [CSS-Grid 課程](https://cssgrid.io/)
- 作者 [**Wes Bos** CSS-Grid Github](https://github.com/wesbos/css-grid)
- 我的 CSS-Grid [練習Github](https://github.com/shunnien/css-grid25day)

[1]: https://developer.mozilla.org/zh-TW/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes
[2]: https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-direction
[3]: https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction
[4]: https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex-wrap